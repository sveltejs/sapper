[{"html":"\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Before_we_begin\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Before_we_begin\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tBefore we begin\n\t\t\t\t\t</h3><blockquote>\n<p>Sapper has been deprecated in favor of <a href=\"https://kit.svelte.dev\" target=\"_blank\" rel=\"noopener noreferrer\">SvelteKit</a>. We recommend using <a href=\"https://kit.svelte.dev\" target=\"_blank\" rel=\"noopener noreferrer\">SvelteKit</a> for all projects moving forward. Sapper will no be receiving security fixes, bug fixes, or any type of improvements.</p>\n<p>See the <a href=\"https://kit.svelte.dev/docs/migrating\" target=\"_blank\" rel=\"noopener noreferrer\">migration guide</a> for help migrating from Sapper to SvelteKit. If you get stuck, reach out for help in the <a href=\"https://svelte.dev/chat\" target=\"_blank\" rel=\"noopener noreferrer\">Discord chatroom</a>.</p>\n</blockquote>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"What_is_Sapper\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#What_is_Sapper\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tWhat is Sapper?\n\t\t\t\t\t</h3><p>Sapper is a framework for building extremely high-performance web apps. You&#39;re looking at one right now! There are two basic concepts:</p>\n<ul>\n<li>Each page of your app is a <a href=\"https://svelte.dev\" target=\"_blank\" rel=\"noopener noreferrer\">Svelte</a> component</li>\n<li>You create pages by adding files to the <code>src/routes</code> directory of your project. These will be server-rendered so that a user&#39;s first visit to your app is as fast as possible, then a client-side app takes over</li>\n</ul>\n<p>Building an app with all the modern best practices — code-splitting, offline support, server-rendered views with client-side hydration — is fiendishly complicated. Sapper does all the boring stuff for you so that you can get on with the creative part.</p>\n<p>You don&#39;t need to know Svelte to understand the rest of this guide, but it will help. In short, it&#39;s a UI framework that compiles your components to highly optimized vanilla JavaScript. Read the <a href=\"https://svelte.dev/blog/svelte-3-rethinking-reactivity\" target=\"_blank\" rel=\"noopener noreferrer\">introductory blog post</a> and the <a href=\"https://svelte.dev/tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">tutorial</a> to learn more.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Why_the_name\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Why_the_name\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tWhy the name?\n\t\t\t\t\t</h3><p>In war, the soldiers who build bridges, repair roads, clear minefields and conduct demolitions — all under combat conditions — are known as <em>sappers</em>.</p>\n<p>For web developers, the stakes are generally lower than for combat engineers. But we face our own hostile environment: underpowered devices, poor network connections, and the complexity inherent in front-end engineering. Sapper, which is short for <b>S</b>velte <b>app</b> mak<b>er</b>, is your courageous and dutiful ally.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Comparison_with_Next_js\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Comparison_with_Next_js\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tComparison with Next.js\n\t\t\t\t\t</h3><p><a href=\"https://github.com/zeit/next.js\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js</a> is a React framework from <a href=\"https://vercel.com\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel (formerly ZEIT)</a>, and is the inspiration for Sapper. There are a few notable differences, however:</p>\n<ul>\n<li>Sapper is powered by Svelte instead of React, so it&#39;s faster and your apps are smaller</li>\n<li>As well as <em>pages</em>, you can create <em>server routes</em> in your <code>src/routes</code> directory. This makes it very easy to, for example, add a JSON API such as the one powering this very page (try visiting <a href=\"/docs.json\" rel=\"noopener noreferrer\">/docs.json</a>)</li>\n<li>Links are just <code>&lt;a&gt;</code> elements, rather than framework-specific <code>&lt;Link&gt;</code> components. That means, for example, that <a href=\"/\" rel=\"noopener noreferrer\">this link right here</a>, despite being inside a blob of markdown, works with the router as you&#39;d expect</li>\n</ul>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Getting_started\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Getting_started\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tGetting started\n\t\t\t\t\t</h3><p>The easiest way to start building a Sapper app is to clone the <a href=\"https://github.com/sveltejs/sapper-template\" target=\"_blank\" rel=\"noopener noreferrer\">sapper-template</a> repo with <a href=\"https://github.com/Rich-Harris/degit\" target=\"_blank\" rel=\"noopener noreferrer\">degit</a>:</p>\n<div class=''><pre class='language-bash'><code>npx degit <span class=\"hljs-string\">&quot;sveltejs/sapper-template#rollup&quot;</span> my-app\n<span class=\"hljs-comment\"># or: npx degit &quot;sveltejs/sapper-template#webpack&quot; my-app</span>\n<span class=\"hljs-built_in\">cd</span> my-app\nnpm install\nnpm run dev</code></pre></div><p>This will scaffold a new project in the <code>my-app</code> directory, install its dependencies, and start a server on <a href=\"http://localhost:3000\" target=\"_blank\" rel=\"noopener noreferrer\">localhost:3000</a>. Try editing the files to get a feel for how everything works – you may not need to bother reading the rest of this guide!</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"TypeScript_support\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#TypeScript_support\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tTypeScript support\n\t\t\t\t\t</h4><p>Sapper supports TypeScript. If you are using the template with Rollup as described in &quot;Getting started&quot; you can convert your project to TypeScript simply by running:</p>\n<div class=''><pre class='language-bash'><code>node scripts/setupTypeScript.js</code></pre></div>","metadata":{"title":"Introduction"},"subsections":[{"slug":"Before_we_begin","title":"Before we begin","level":3},{"slug":"What_is_Sapper","title":"What is Sapper?","level":3},{"slug":"Why_the_name","title":"Why the name?","level":3},{"slug":"Comparison_with_Next_js","title":"Comparison with Next.js","level":3},{"slug":"Getting_started","title":"Getting started","level":3},{"slug":"TypeScript_support","title":"TypeScript support","level":4}],"slug":"Introduction","file":"00-introduction.md"},{"html":"<p>If you take a look inside the <a href=\"https://github.com/sveltejs/sapper-template\" target=\"_blank\" rel=\"noopener noreferrer\">sapper-template</a> repo, you&#39;ll see some files that Sapper expects to find:</p>\n<div class=''><pre class='language-bash'><code>├ package.json\n├ src\n│ ├ routes\n│ │ ├ <span class=\"hljs-comment\"># your routes here</span>\n│ │ ├ _error.svelte\n│ │ └ index.svelte\n│ ├ client.js\n│ ├ server.js\n│ ├ service-worker.js\n│ └ template.html\n├ static\n│ ├ <span class=\"hljs-comment\"># your files here</span>\n└ rollup.config.js / webpack.config.js</code></pre></div><p>When you first run Sapper, it will create an additional <code>__sapper__</code> directory containing generated files.</p>\n<p>You&#39;ll notice a few extra files — we don&#39;t need to worry about those right now.</p>\n<blockquote>\n<p>You <em>can</em> create these files from scratch, but it&#39;s much better to use the template. See <a href=\"docs#Getting_started\" rel=\"noopener noreferrer\">getting started</a> for instructions on how to easily clone it</p>\n</blockquote>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"package_json\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#package_json\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tpackage.json\n\t\t\t\t\t</h3><p>Your package.json contains your app&#39;s dependencies and defines a number of scripts:</p>\n<ul>\n<li><code>npm run dev</code> — start the app in development mode, and watch source files for changes</li>\n<li><code>npm run build</code> — build the app in production mode</li>\n<li><code>npm run export</code> — bake out a static version, if applicable (see <a href=\"docs#Exporting\" rel=\"noopener noreferrer\">exporting</a>)</li>\n<li><code>npm start</code> — start the app in production mode after you&#39;ve built it</li>\n</ul>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"src\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc\n\t\t\t\t\t</h3><p>This contains the three <em>entry points</em> for your app — <code>src/client.js</code>, <code>src/server.js</code> and (optionally) <code>src/service-worker.js</code> — along with a <code>src/template.html</code> file.</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"src_client_js\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src_client_js\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc/client.js\n\t\t\t\t\t</h4><p>This <em>must</em> import, and call, the <code>start</code> function from the generated <code>@sapper/app</code> module:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> sapper <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@sapper/app&#x27;</span>;\n\nsapper.start({\n\t<span class=\"hljs-attr\">target</span>: <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;#sapper&#x27;</span>)\n});</code></pre></div><p>In many cases, that&#39;s the entirety of your entry module, though you can do as much or as little here as you wish. See the <a href=\"docs#Client_API\" rel=\"noopener noreferrer\">client API</a> section for more information on functions you can import.</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"src_server_js\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src_server_js\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc/server.js\n\t\t\t\t\t</h4><p>This is a normal Express (or <a href=\"https://github.com/lukeed/polka\" target=\"_blank\" rel=\"noopener noreferrer\">Polka</a>, etc) app, with three requirements:</p>\n<ul>\n<li>it should serve the contents of the <code>static</code> folder, using for example <a href=\"https://github.com/lukeed/sirv\" target=\"_blank\" rel=\"noopener noreferrer\">sirv</a></li>\n<li>it should call <code>app.use(sapper.middleware())</code> at the end, where <code>sapper</code> is imported from <code>@sapper/server</code></li>\n<li>it must listen on <code>process.env.PORT</code></li>\n</ul>\n<p>Beyond that, you can write the server however you like.</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"src_service-worker_js\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src_service-worker_js\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc/service-worker.js\n\t\t\t\t\t</h4><p>Service workers act as proxy servers that give you fine-grained control over how to respond to network requests. For example, when the browser requests <code>/goats.jpg</code>, the service worker can respond with a file it previously cached, or it can pass the request on to the server, or it could even respond with something completely different, such as a picture of llamas.</p>\n<p>Among other things, this makes it possible to build applications that work offline.</p>\n<p>Because every app needs a slightly different service worker (sometimes it&#39;s appropriate to always serve from the cache, sometimes that should only be a last resort in case of no connectivity), Sapper doesn&#39;t attempt to control the service worker. Instead, you write the logic in <code>service-worker.js</code>. You can import any of the following from <code>@sapper/service-worker</code>:</p>\n<ul>\n<li><code>files</code> — an array of files found in the <code>static</code> directory</li>\n<li><code>shell</code> — the client-side JavaScript generated by the bundler (Rollup or webpack)</li>\n<li><code>routes</code> — an array of <code>{ pattern: RegExp }</code> objects you can use to determine whether a Sapper-controlled page is being requested</li>\n<li><code>timestamp</code> — the time the service worker was generated (useful for generating unique cache names)</li>\n</ul>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"src_template_html\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src_template_html\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc/template.html\n\t\t\t\t\t</h4><p>This file is a template for responses from the server. Sapper will inject content that replaces the following tags:</p>\n<ul>\n<li><code>%sapper.base%</code> — a <code>&lt;base&gt;</code> element (see <a href=\"docs#Base_URLs\" rel=\"noopener noreferrer\">base URLs</a>)</li>\n<li><code>%sapper.styles%</code> — critical CSS for the page being requested</li>\n<li><code>%sapper.head%</code> — HTML representing page-specific <code>&lt;head&gt;</code> contents, like <code>&lt;title&gt;</code></li>\n<li><code>%sapper.html%</code> — HTML representing the body of the page being rendered</li>\n<li><code>%sapper.scripts%</code> — script tags for the client-side app</li>\n<li><code>%sapper.cspnonce%</code> — CSP nonce taken from <code>res.locals.nonce</code> (see <a href=\"docs#Content_Security_Policy_CSP\" rel=\"noopener noreferrer\">Content Security Policy (CSP)</a>)</li>\n</ul>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"src_routes\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src_routes\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc/routes\n\t\t\t\t\t</h3><p>This is the meat of your app — the pages and server routes. See the section on <a href=\"docs#Routing\" rel=\"noopener noreferrer\">routing</a> for the juicy details.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"static\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#static\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tstatic\n\t\t\t\t\t</h3><p>This is a place to put any files that your app uses — fonts, images and so on. For example <code>static/favicon.png</code> will be served as <code>/favicon.png</code>.</p>\n<p>Sapper doesn&#39;t serve these files — you&#39;d typically use <a href=\"https://github.com/lukeed/sirv\" target=\"_blank\" rel=\"noopener noreferrer\">sirv</a> or <a href=\"https://github.com/expressjs/serve-static\" target=\"_blank\" rel=\"noopener noreferrer\">serve-static</a> for that — but it will read the contents of the <code>static</code> folder so that you can easily generate a cache manifest for offline support (see <a href=\"docs#src_service-worker_js\" rel=\"noopener noreferrer\">service-worker.js</a>).</p>\n<blockquote>\n<p>Note that the default behaviour of the service worker is to cache all assets from the static directory, so if you have more than 50mb of files here, you will start to exceed the cache limit for service-workers in some browsers, which can cause the service worker to stop loading. In this instance, it is advisable to customise what files are cached by editing the service-worker yourself.</p>\n</blockquote>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"rollup_config_js_webpack_config_js\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#rollup_config_js_webpack_config_js\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\trollup.config.js / webpack.config.js\n\t\t\t\t\t</h3><p>Sapper can use <a href=\"https://rollupjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Rollup</a> or <a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener noreferrer\">webpack</a> to bundle your app. You probably won&#39;t need to change the config, but if you want to (for example to add new loaders or plugins), you can.</p>\n","metadata":{"title":"Sapper app structure"},"subsections":[{"slug":"package_json","title":"package.json","level":3},{"slug":"src","title":"src","level":3},{"slug":"src_client_js","title":"src/client.js","level":4},{"slug":"src_server_js","title":"src/server.js","level":4},{"slug":"src_service-worker_js","title":"src/service-worker.js","level":4},{"slug":"src_template_html","title":"src/template.html","level":4},{"slug":"src_routes","title":"src/routes","level":3},{"slug":"static","title":"static","level":3},{"slug":"rollup_config_js_webpack_config_js","title":"rollup.config.js / webpack.config.js","level":3}],"slug":"Sapper_app_structure","file":"01-structure.md"},{"html":"<p>As we&#39;ve seen, there are two types of route in Sapper — pages, and server routes.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Pages\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Pages\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tPages\n\t\t\t\t\t</h3><p>Pages are Svelte components written in <code>.svelte</code> files. When a user first visits the application, they will be served a server-rendered version of the route in question, plus some JavaScript that &#39;hydrates&#39; the page and initialises a client-side router. From that point forward, navigating to other pages is handled entirely on the client for a fast, app-like feel.</p>\n<p>The filename determines the route. For example, <code>src/routes/index.svelte</code> is the root of your site:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/index.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Welcome<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello and welcome to my site!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre></div><p>A file called either <code>src/routes/about.svelte</code> or <code>src/routes/about/index.svelte</code> would correspond to the <code>/about</code> route:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/about.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>About<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>About this site<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>TODO...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre></div><p>Dynamic parameters are encoded using <code>[brackets]</code>. For example, here&#39;s how you could create a page that renders a blog post:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/blog/[slug].svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-comment\">// the (optional) preload function takes a</span>\n\t<span class=\"hljs-comment\">// `{ path, params, query }` object and turns it into</span>\n\t<span class=\"hljs-comment\">// the data we need to render the page</span>\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\">page, session</span>) </span>{\n\t\t<span class=\"hljs-comment\">// the `slug` parameter is available because this file</span>\n\t\t<span class=\"hljs-comment\">// is called [slug].svelte</span>\n\t\t<span class=\"hljs-keyword\">const</span> { slug } = page.params;\n\n\t\t<span class=\"hljs-comment\">// `this.fetch` is a wrapper around `fetch` that allows</span>\n\t\t<span class=\"hljs-comment\">// you to make credentialled requests on both</span>\n\t\t<span class=\"hljs-comment\">// server and client</span>\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">this</span>.fetch(<span class=\"hljs-string\">`blog/<span class=\"hljs-subst\">${slug}</span>.json`</span>);\n\t\t<span class=\"hljs-keyword\">const</span> article = <span class=\"hljs-keyword\">await</span> res.json();\n\n\t\t<span class=\"hljs-keyword\">return</span> { article };\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> article;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>{article.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>{article.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&#x27;content&#x27;</span>&gt;</span>\n\t{@html article.html}\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre></div><p>If you want to capture more params, you can create nested folders using the same naming convention: <code>[slug]/[language]</code>.</p>\n<p>If you don&#39;t want to create several folders to capture more than one parameter like <code>[year]/[month]/...</code>, or if the number of parameters is dynamic, you can use a spread route parameter. For example, instead of individually capturing <code>/blog/[slug]/[year]/[month]/[day]</code>, you can create a file for <code>/blog/[...slug].svelte</code> and extract the params like so:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/blog/[...slug].svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\">{ params }</span>) </span>{\n\t\t<span class=\"hljs-keyword\">let</span> [slug, year, month, day] = params.slug;\n\n\t\t<span class=\"hljs-keyword\">return</span> { slug, year, month, day };\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div><blockquote>\n<p>See the section on <a href=\"docs#Preloading\" rel=\"noopener noreferrer\">preloading</a> for more info about <code>preload</code> and <code>this.fetch</code></p>\n</blockquote>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Server_routes\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Server_routes\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tServer routes\n\t\t\t\t\t</h3><p>Server routes are modules written in <code>.js</code> files that export functions corresponding to HTTP methods. Each function receives HTTP <code>request</code> and <code>response</code> objects as arguments, plus a <code>next</code> function. This is useful for creating a JSON API. For example, here&#39;s how you could create an endpoint that served the blog page above:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-comment\">// routes/blog/[slug].json.js</span>\n<span class=\"hljs-keyword\">import</span> db <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./_database.js&#x27;</span>; <span class=\"hljs-comment\">// the underscore tells Sapper this isn&#x27;t a route</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">get</span>(<span class=\"hljs-params\">req, res, next</span>) </span>{\n\t<span class=\"hljs-comment\">// the `slug` parameter is available because this file</span>\n\t<span class=\"hljs-comment\">// is called [slug].json.js</span>\n\t<span class=\"hljs-keyword\">const</span> { slug } = req.params;\n\n\t<span class=\"hljs-keyword\">const</span> article = <span class=\"hljs-keyword\">await</span> db.get(slug);\n\n\t<span class=\"hljs-keyword\">if</span> (article !== <span class=\"hljs-literal\">null</span>) {\n\t\tres.setHeader(<span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>, <span class=\"hljs-string\">&#x27;application/json&#x27;</span>);\n\t\tres.end(<span class=\"hljs-built_in\">JSON</span>.stringify(article));\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\tnext();\n\t}\n}</code></pre></div><blockquote>\n<p><code>delete</code> is a reserved word in JavaScript. To handle DELETE requests, export a function called <code>del</code> instead.</p>\n</blockquote>\n<p>If you are using TypeScript, use the following types:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-keyword\">import</span> { SapperRequest, SapperResponse } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@sapper/server&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">get</span>(<span class=\"hljs-params\">req: SapperRequest, res: SapperResponse, next: () =&gt; <span class=\"hljs-keyword\">void</span></span>) </span>{ ... }</code></pre></div><p><code>SapperRequest</code> and <code>SapperResponse</code> will work with both Polka and Express. You can replace them with the types specific to your server, which are <code>polka.Request</code> / <code>http.ServerResponse</code> and <code>express.Request</code> / <code>express.Response</code>, respectively.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"File_naming_rules\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#File_naming_rules\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tFile naming rules\n\t\t\t\t\t</h3><p>There are three simple rules for naming the files that define your routes:</p>\n<ul>\n<li>A file called <code>src/routes/about.svelte</code> corresponds to the <code>/about</code> route. A file called <code>src/routes/blog/[slug].svelte</code> corresponds to the <code>/blog/:slug</code> route, in which case <code>params.slug</code> is available to <code>preload</code></li>\n<li>The file <code>src/routes/index.svelte</code> corresponds to the root of your app. <code>src/routes/about/index.svelte</code> is treated the same as <code>src/routes/about.svelte</code>.</li>\n<li>Files and directories with a leading underscore do <em>not</em> create routes. This allows you to colocate helper modules and components with the routes that depend on them — for example you could have a file called <code>src/routes/_helpers/datetime.js</code> and it would <em>not</em> create a <code>/_helpers/datetime</code> route</li>\n</ul>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Error_page\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Error_page\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tError page\n\t\t\t\t\t</h3><p>In addition to regular pages, there is a &#39;special&#39; page that Sapper expects to find — <code>src/routes/_error.svelte</code>. This will be shown when an error occurs while rendering a page.</p>\n<p>The <code>error</code> object is made available to the template along with the HTTP <code>status</code> code. <code>error</code> is also available in the <a href=\"docs#Stores\" rel=\"noopener noreferrer\"><code>page</code> store</a>.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Regexes_in_routes\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Regexes_in_routes\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tRegexes in routes\n\t\t\t\t\t</h3><p>You can use a subset of regular expressions to qualify route parameters, by placing them in parentheses after the parameter name.</p>\n<p>For example, <code>src/routes/items/[id([0-9]+)].svelte</code> would only match numeric IDs — <code>/items/123</code> would match and make the value <code>123</code> available in <code>page.params.id</code>, but <code>/items/xyz</code> would not match.</p>\n<p>Because of technical limitations, the following characters cannot be used: <code>/</code>, <code>\\</code>, <code>?</code>, <code>:</code>, <code>(</code> and <code>)</code>.</p>\n","metadata":{"title":"Routing"},"subsections":[{"slug":"Pages","title":"Pages","level":3},{"slug":"Server_routes","title":"Server routes","level":3},{"slug":"File_naming_rules","title":"File naming rules","level":3},{"slug":"Error_page","title":"Error page","level":3},{"slug":"Regexes_in_routes","title":"Regexes in routes","level":3}],"slug":"Routing","file":"02-routing.md"},{"html":"<p>The <code>@sapper/app</code> module, which is generated by Sapper based on the shape of your app, contains functions for controlling Sapper programmatically and responding to events.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"start_target\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#start_target\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tstart({ target })\n\t\t\t\t\t</h3><ul>\n<li><code>target</code> — an element to render pages to</li>\n</ul>\n<p>This configures the router and starts the application — listens for clicks on <code>&lt;a&gt;</code> elements, interacts with the <code>history</code> API, and renders and updates your Svelte components.</p>\n<p>Returns a <code>Promise</code> that resolves when the initial page has been hydrated.</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> sapper <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@sapper/app&#x27;</span>;\n\nsapper.start({\n\t<span class=\"hljs-attr\">target</span>: <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;#sapper&#x27;</span>)\n}).then(<span class=\"hljs-function\">() =&gt;</span> {\n\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;client-side app has started&#x27;</span>);\n});</code></pre></div>\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"goto_href_options\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#goto_href_options\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tgoto(href, options?)\n\t\t\t\t\t</h3><ul>\n<li><code>href</code> — the page to go to</li>\n<li><code>options</code> — not required<ul>\n<li><code>replaceState</code> (<code>boolean</code>, default <code>false</code>) — determines whether to use <code>history.pushState</code> (the default) or <code>history.replaceState</code>.</li>\n<li><code>noscroll</code> (<code>boolean</code>, default <code>false</code>) — prevent scroll to top after navigation.</li>\n</ul>\n</li>\n</ul>\n<p>Programmatically navigates to the given <code>href</code>. If the destination is a Sapper route, Sapper will handle the navigation, otherwise the page will be reloaded with the new <code>href</code>. In other words, the behaviour is as though the user clicked on a link with this <code>href</code>.</p>\n<p>Returns a <code>Promise</code> that resolves when the navigation is complete. This can be used to perform actions once the navigation has completed, such as updating a database, store, etc.</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-keyword\">import</span> { goto } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@sapper/app&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> navigateAndSave = <span class=\"hljs-keyword\">async</span> () =&gt; {\n\t<span class=\"hljs-keyword\">await</span> goto(<span class=\"hljs-string\">&#x27;/&#x27;</span>);\n\tsaveItem();\n}\n\n<span class=\"hljs-keyword\">const</span> saveItem = <span class=\"hljs-function\">() =&gt;</span> {\n\t<span class=\"hljs-comment\">// do something with the database</span>\n}</code></pre></div>\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"prefetch_href\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#prefetch_href\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tprefetch(href)\n\t\t\t\t\t</h3><ul>\n<li><code>href</code> — the page to prefetch</li>\n</ul>\n<p>Programmatically prefetches the given page, which means a) ensuring that the code for the page is loaded, and b) calling the page&#39;s <code>preload</code> method with the appropriate options. This is the same behaviour that Sapper triggers when the user taps or mouses over an <code>&lt;a&gt;</code> element with <a href=\"docs#sapper_prefetch\" rel=\"noopener noreferrer\">sapper:prefetch</a>.</p>\n<p>Returns a <code>Promise</code> that resolves when the prefetch is complete.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"prefetchRoutes_routes\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#prefetchRoutes_routes\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tprefetchRoutes(routes?)\n\t\t\t\t\t</h3><ul>\n<li><code>routes</code> — an optional array of strings representing routes to prefetch</li>\n</ul>\n<p>Programmatically prefetches the code for routes that haven&#39;t yet been fetched. Typically, you might call this after <code>sapper.start()</code> is complete, to speed up subsequent navigation (this is the &#39;L&#39; of the <a href=\"https://developers.google.com/web/fundamentals/performance/prpl-pattern/\" target=\"_blank\" rel=\"noopener noreferrer\">PRPL pattern</a>). Omitting arguments will cause all routes to be fetched, or you can specify routes by any matching pathname such as <code>/about</code> (to match <code>src/routes/about.svelte</code>) or <code>/blog/*</code> (to match <code>src/routes/blog/[slug].svelte</code>). Unlike <code>prefetch</code>, this won&#39;t call <code>preload</code> for individual pages.</p>\n<p>Returns a <code>Promise</code> that resolves when the routes have been prefetched.</p>\n","metadata":{"title":"Client API"},"subsections":[{"slug":"start_target","title":"start({ target })","level":3},{"slug":"goto_href_options","title":"goto(href, options?)","level":3},{"slug":"prefetch_href","title":"prefetch(href)","level":3},{"slug":"prefetchRoutes_routes","title":"prefetchRoutes(routes?)","level":3}],"slug":"Client_API","file":"03-client-api.md"},{"html":"<p>Page components can define a <code>preload</code> function that runs before the component is created. The values it returns are passed as props to the page.</p>\n<p><code>preload</code> functions are called when a page is loaded and are typically used to load data that the page depends on - hence its name. This avoids the user seeing the page update as it loads, as is typically the case with client-side loading.</p>\n<p><code>preload</code> is the Sapper equivalent to <code>getInitialProps</code> in Next.js or <code>asyncData</code> in Nuxt.js.</p>\n<p>Note that <code>preload</code> will run both on the server side and on the client side. It may therefore not reference any APIs only present in the browser.</p>\n<p>The following code shows how to load a blog post and pass it to the page in the <code>article</code> prop:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\">page, session</span>) </span>{\n\t\t<span class=\"hljs-keyword\">const</span> { slug } = page.params;\n\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">this</span>.fetch(<span class=\"hljs-string\">`blog/<span class=\"hljs-subst\">${slug}</span>.json`</span>);\n\t\t<span class=\"hljs-keyword\">const</span> article = <span class=\"hljs-keyword\">await</span> res.json();\n\n\t\t<span class=\"hljs-keyword\">return</span> { article };\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> article;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>{article.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre></div><p>The <a href=\"docs#Routing\" rel=\"noopener noreferrer\">routing section</a> describes how the dynamic parameter <code>slug</code> works.</p>\n<p>It should be defined in a <code>context=&quot;module&quot;</code> script since it is not part of the component instance itself – it runs before the component has been created. See the <a href=\"https://svelte.dev/tutorial/module-exports\" target=\"_blank\" rel=\"noopener noreferrer\">tutorial</a> for more on the module context.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Arguments\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Arguments\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tArguments\n\t\t\t\t\t</h3><p>The <code>preload</code> function receives two arguments — <code>page</code> and <code>session</code>.</p>\n<p><code>page</code> is a <code>{ host, path, params, query }</code> object where <code>host</code> is the URL&#39;s host, <code>path</code> is its pathname, <code>params</code> is derived from <code>path</code> and the route filename, and <code>query</code> is an object of values in the query string.</p>\n<p>So if the example above was <code>src/routes/blog/[slug].svelte</code> and the URL was <code>/blog/some-post?foo=bar&amp;baz</code>, the following would be true:</p>\n<ul>\n<li><code>page.path === &#39;/blog/some-post&#39;</code></li>\n<li><code>page.params.slug === &#39;some-post&#39;</code></li>\n<li><code>page.query.foo === &#39;bar&#39;</code></li>\n<li><code>page.query.baz === true</code></li>\n</ul>\n<p><code>session</code> can be used to pass data from the server related to the current request, e.g. the current user. By default it is <code>undefined</code>. <a href=\"docs#Seeding_session_data\" rel=\"noopener noreferrer\">Seeding session data</a> describes how to add data to it.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Return_value\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Return_value\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tReturn value\n\t\t\t\t\t</h3><p>If you return a Promise from <code>preload</code>, the page will delay rendering until the promise resolves. You can also return a plain object. In both cases, the values in the object will be passed into the components as props.</p>\n<p>When Sapper renders a page on the server, it will attempt to serialize the resolved value (using <a href=\"https://github.com/Rich-Harris/devalue\" target=\"_blank\" rel=\"noopener noreferrer\">devalue</a>) and include it on the page, so that the client doesn&#39;t also need to call <code>preload</code> upon initialization. Serialization will fail if the value includes functions or custom classes (cyclical and repeated references are fine, as are built-ins like <code>Date</code>, <code>Map</code>, <code>Set</code> and <code>RegExp</code>).</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Context\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Context\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tContext\n\t\t\t\t\t</h3><p>Inside <code>preload</code>, you have access to three methods:</p>\n<ul>\n<li><code>this.fetch(url, options)</code></li>\n<li><code>this.error(statusCode, error)</code></li>\n<li><code>this.redirect(statusCode, location)</code></li>\n</ul>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"this_fetch\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#this_fetch\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tthis.fetch\n\t\t\t\t\t</h4><p>In browsers, you can use <code>fetch</code> to make AJAX requests, for getting data from your server routes (among other things). On the server it&#39;s a little trickier — you can make HTTP requests, but you must specify an origin, and you don&#39;t have access to cookies. This means that it&#39;s impossible to request data based on the user&#39;s session, such as data that requires you to be logged in.</p>\n<p>To fix this, Sapper provides <code>this.fetch</code>, which works on the server as well as in the client:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\"></span>) </span>{\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">this</span>.fetch(<span class=\"hljs-string\">`server-route.json`</span>);\n\n\t\t<span class=\"hljs-comment\">// ...</span>\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div><p>It is important to note that <code>preload</code> may run on either the server or in the client browser. Code called inside <code>preload</code> blocks:</p>\n<ul>\n<li>should run on the same domain as any upstream API servers requiring credentials</li>\n<li>should not reference <code>window</code>, <code>document</code> or any browser-specific objects</li>\n<li>should not reference any API keys or secrets, which will be exposed to the client</li>\n</ul>\n<p>If you are using Sapper as an authentication/authorization server, you can use session middleware such as <a href=\"https://github.com/expressjs/session\" target=\"_blank\" rel=\"noopener noreferrer\">express-session</a> in your <code>app/server.js</code> in order to maintain user sessions.</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"this_error\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#this_error\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tthis.error\n\t\t\t\t\t</h4><p>If the user navigated to <code>/blog/some-invalid-slug</code>, we would want to render a 404 Not Found page. We can do that with <code>this.error</code>:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\">{ params, query }</span>) </span>{\n\t\t<span class=\"hljs-keyword\">const</span> { slug } = params;\n\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">this</span>.fetch(<span class=\"hljs-string\">`blog/<span class=\"hljs-subst\">${slug}</span>.json`</span>);\n\n\t\t<span class=\"hljs-keyword\">if</span> (res.status === <span class=\"hljs-number\">200</span>) {\n\t\t\t<span class=\"hljs-keyword\">const</span> article = <span class=\"hljs-keyword\">await</span> res.json();\n\t\t\t<span class=\"hljs-keyword\">return</span> { article };\n\t\t}\n\n\t\t<span class=\"hljs-built_in\">this</span>.error(<span class=\"hljs-number\">404</span>, <span class=\"hljs-string\">&#x27;Not found&#x27;</span>);\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div><p>The same applies to other error codes you might encounter.</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"this_redirect\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#this_redirect\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tthis.redirect\n\t\t\t\t\t</h4><p>You can abort rendering and redirect to a different location with <code>this.redirect</code>:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\">page, session</span>) </span>{\n\t\t<span class=\"hljs-keyword\">const</span> { user } = session;\n\n\t\t<span class=\"hljs-keyword\">if</span> (!user) {\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.redirect(<span class=\"hljs-number\">302</span>, <span class=\"hljs-string\">&#x27;login&#x27;</span>);\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">return</span> { user };\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div>\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"Typing_the_function\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Typing_the_function\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tTyping the function\n\t\t\t\t\t</h4><p>If you use TypeScript and want to access the above context methods, TypeScript will throw an error and tell you that it does not know the type of <code>this</code>. To fix it, you need to specify the type of <code>this</code> (see the <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#specifying-the-type-of-this-for-functions\" target=\"_blank\" rel=\"noopener noreferrer\">official TypeScript documentation</a>). We provide you with helper interfaces so you can type the function like this:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">&quot;module&quot;</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;ts&quot;</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> type { Preload } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@sapper/common&quot;</span>;\n\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> preload: Preload = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">this</span>, page, session</span>) </span>{\n\t\t<span class=\"hljs-keyword\">const</span> { user } = session;\n\n\t\t<span class=\"hljs-keyword\">if</span> (!user) {\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.redirect(<span class=\"hljs-number\">302</span>, <span class=\"hljs-string\">&#x27;login&#x27;</span>); <span class=\"hljs-comment\">// TypeScript will know the type of `this` now</span>\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">return</span> { user };\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div>","metadata":{"title":"Preloading"},"subsections":[{"slug":"Arguments","title":"Arguments","level":3},{"slug":"Return_value","title":"Return value","level":3},{"slug":"Context","title":"Context","level":3},{"slug":"this_fetch","title":"this.fetch","level":4},{"slug":"this_error","title":"this.error","level":4},{"slug":"this_redirect","title":"this.redirect","level":4},{"slug":"Typing_the_function","title":"Typing the function","level":4}],"slug":"Preloading","file":"04-preloading.md"},{"html":"<p>So far, we&#39;ve treated pages as entirely standalone components — upon navigation, the existing component will be destroyed, and a new one will take its place.</p>\n<p>But in many apps, there are elements that should be visible on <em>every</em> page, such as top-level navigation or a footer. Instead of repeating them in every page, we can use <em>layout</em> components.</p>\n<p>To create a layout component that applies to every page, make a file called <code>src/routes/_layout.svelte</code>. The default layout component (the one that Sapper uses if you don&#39;t bring your own) looks like this...</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span></code></pre></div><p>...but we can add whatever markup, styles and behaviour we want. For example, let&#39;s add a nav bar:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/_layout.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;.&quot;</span>&gt;</span>Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;about&quot;</span>&gt;</span>About<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;settings&quot;</span>&gt;</span>Settings<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span></code></pre></div><p>If we create pages for <code>/</code>, <code>/about</code> and <code>/settings</code>...</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/index.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre></div><div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/about.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>About<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre></div><div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/settings.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Settings<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre></div><p>...the nav will always be visible, and clicking between the three pages will only result in the <code>&lt;h1&gt;</code> being replaced.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Nested_routes\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Nested_routes\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tNested routes\n\t\t\t\t\t</h3><p>Suppose we don&#39;t just have a single <code>/settings</code> page, but instead have nested pages like <code>/settings/profile</code> and <code>/settings/notifications</code> with a shared submenu (for a real-life example, see <a href=\"https://github.com/settings\" target=\"_blank\" rel=\"noopener noreferrer\">github.com/settings</a>).</p>\n<p>We can create a layout that only applies to pages below <code>/settings</code> (while inheriting the root layout with the top-level nav):</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/settings/_layout.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Settings<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;submenu&quot;</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;settings/profile&quot;</span>&gt;</span>Profile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;settings/notifications&quot;</span>&gt;</span>Notifications<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span></code></pre></div><p>Layout components receive a <code>segment</code> property which is useful for things like styling:</p>\n<div class=''><pre class='language-diff'><code><span class=\"hljs-addition\">+&lt;script&gt;</span>\n<span class=\"hljs-addition\">+    export let segment;</span>\n<span class=\"hljs-addition\">+&lt;/script&gt;</span>\n<span class=\"hljs-addition\">+</span>\n&lt;div class=&quot;submenu&quot;&gt;\n<span class=\"hljs-deletion\">-    &lt;a href=&quot;settings/profile&quot;&gt;Profile&lt;/a&gt;</span>\n<span class=\"hljs-deletion\">-    &lt;a href=&quot;settings/notifications&quot;&gt;Notifications&lt;/a&gt;</span>\n<span class=\"hljs-addition\">+    &lt;a</span>\n<span class=\"hljs-addition\">+        class:selected={segment === &quot;profile&quot;}</span>\n<span class=\"hljs-addition\">+        href=&quot;settings/profile&quot;</span>\n<span class=\"hljs-addition\">+    &gt;Profile&lt;/a&gt;</span>\n<span class=\"hljs-addition\">+</span>\n<span class=\"hljs-addition\">+    &lt;a</span>\n<span class=\"hljs-addition\">+        class:selected={segment === &quot;notifications&quot;}</span>\n<span class=\"hljs-addition\">+        href=&quot;settings/notifications&quot;</span>\n<span class=\"hljs-addition\">+    &gt;Notifications&lt;/a&gt;</span>\n&lt;/div&gt;</code></pre></div>","metadata":{"title":"Layouts"},"subsections":[{"slug":"Nested_routes","title":"Nested routes","level":3}],"slug":"Layouts","file":"05-layouts.md"},{"html":"<p>Sapper will render any component first on the server side and send it to the client as HTML. It will then run the component again on the client side to allow it to update based on dynamic data. This means you need to ensure that components can run both on the client and server side.</p>\n<p>If, for example, your components try to access the global variables <code>document</code> or <code>window</code>, this will result in an error when the page is pre-rendered on the server side.</p>\n<p>If you need access to these variables, you can run code exclusively on the client side by wrapping it in</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">window</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span>) {\n\t<span class=\"hljs-comment\">// client-only code here</span>\n}</code></pre></div><p>Alternatively, you can run it <code>onMount</code> (see below).</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Third-party_libraries_that_depend_on_window\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Third-party_libraries_that_depend_on_window\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tThird-party libraries that depend on <code>window</code>\n\t\t\t\t\t</h3><p>Sapper works well with most third-party libraries you are likely to come across. However, sometimes libraries have implicit dependencies on <code>window</code>.</p>\n<p>A third-party library might come bundled in a way which allows it to work with multiple different module loaders. This code might check for the existence of <code>window.global</code> and therefore depend on <code>window</code>.</p>\n<p>Since Sapper will try to execute your component on the server side – where there is no <code>window</code> – importing such a module will cause the component to fail. You will get an error message saying <code>Server-side code is attempting to access the global variable &quot;window&quot;</code>.</p>\n<p>To solve this, you can load the library by importing it in the <code>onMount</code> function, which is only called on the client. Since this is a dynamic import you need to use <code>await import</code>.</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> { onMount } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;svelte&#x27;</span>;\n\n\t<span class=\"hljs-keyword\">let</span> MyComponent;\n\n\tonMount(<span class=\"hljs-keyword\">async</span> () =&gt; {\n\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">module</span> = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;my-non-ssr-component&#x27;</span>);\n\t\tMyComponent = <span class=\"hljs-built_in\">module</span>.default;\n\t});\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svelte:component</span> <span class=\"hljs-attr\">this</span>=<span class=\"hljs-string\">{MyComponent}</span> <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>/&gt;</span></code></pre></div>","metadata":{"title":"Server-side rendering"},"subsections":[{"slug":"Third-party_libraries_that_depend_on_window","title":"Third-party libraries that depend on window","level":3}],"slug":"Server-side_rendering","file":"06-server-side-rendering.md"},{"html":"<p>The <code>page</code> and <code>session</code> values passed to <code>preload</code> functions are available to components as <a href=\"https://svelte.dev/tutorial/writable-stores\" target=\"_blank\" rel=\"noopener noreferrer\">stores</a>, along with <code>preloading</code>.</p>\n<p>A component can retrieve the stores using the <code>stores</code> function:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> { stores } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@sapper/app&#x27;</span>;\n\t<span class=\"hljs-keyword\">const</span> { preloading, page, session } = stores();\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div><ul>\n<li><code>preloading</code> contains a read-only boolean value, indicating whether or not a navigation is pending</li>\n<li><code>page</code> contains read-only information about the current route. See <a href=\"docs#Arguments\" rel=\"noopener noreferrer\">preloading</a> for details.</li>\n<li><code>session</code> can be used to pass data from the server related to the current request. It is a <a href=\"https://svelte.dev/tutorial/writable-stores\" target=\"_blank\" rel=\"noopener noreferrer\">writable store</a>, meaning you can update it with new data. If, for example, you populate the session with the current user on the server, you can update the store when the user logs in. Your components will refresh to reflect the new state</li>\n</ul>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Seeding_session_data\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Seeding_session_data\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tSeeding session data\n\t\t\t\t\t</h3><p><code>session</code> is <code>undefined</code> by default. To populate it with data, implement a function that returns session data given an HTTP request. Pass it as an option to <code>sapper.middleware</code> when the server is started.</p>\n<p>As an example, let&#39;s look at how to populate the session with the current user. First, add the <code>session</code> parameter to the Sapper middleware:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-comment\">// src/server.js</span>\npolka()\n\t.use(\n\t\t<span class=\"hljs-comment\">// ...</span>\n\t\tsapper.middleware({\n\t\t\t<span class=\"hljs-comment\">// customize the session</span>\n\t\t\t<span class=\"hljs-attr\">session</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> ({\n\t\t\t\t<span class=\"hljs-attr\">user</span>: req.user\n\t\t\t})\n\t\t})\n\t)</code></pre></div><p><code>req</code> is an <code>http.ClientRequest</code> and <code>res</code> an <code>http.ServerResponse</code>.</p>\n<p>The session data must be serializable. This means it must not contain functions or custom classes, just built-in JavaScript data types.</p>\n<p>The <code>session</code> function may return a <code>Promise</code> (or, equivalently, be <code>async</code>).</p>\n<blockquote>\n<p>Note that if <code>session</code> returns a <code>Promise</code> (or is <code>async</code>), it will be re-awaited for on <strong>every</strong> server-rendered page route.</p>\n</blockquote>\n","metadata":{"title":"Stores"},"subsections":[{"slug":"Seeding_session_data","title":"Seeding session data","level":3}],"slug":"Stores","file":"07-state-management.md"},{"html":"\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"sapper_prefetch\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#sapper_prefetch\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsapper:prefetch\n\t\t\t\t\t</h3><p>Sapper uses code splitting to break your app into small chunks (one per route), ensuring fast startup times.</p>\n<p>For <em>dynamic</em> routes, such as our <code>src/routes/blog/[slug].svelte</code> example, that&#39;s not enough. In order to render the blog post, we need to fetch the data for it, and we can&#39;t do that until we know what <code>slug</code> is. In the worst case, that could cause lag as the browser waits for the data to come back from the server.</p>\n<p>We can mitigate that by <em>prefetching</em> the data. Adding a <code>sapper:prefetch</code> attribute to a link...</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">sapper:prefetch</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&#x27;blog/what-is-sapper&#x27;</span>&gt;</span>What is Sapper?<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre></div><p>...will cause Sapper to run the page&#39;s <code>preload</code> function as soon as the user hovers over the link (on a desktop) or touches it (on mobile), rather than waiting for the <code>click</code> event to trigger navigation. Typically, this buys us an extra couple of hundred milliseconds, which is the difference between a user interface that feels laggy, and one that feels snappy.</p>\n<!-- TODO add a function to prefetch programmatically -->\n\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"rel_external\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#rel_external\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\trel=external\n\t\t\t\t\t</h3><p>By default, the Sapper runtime intercepts clicks on <code>&lt;a&gt;</code> elements and bypasses the normal browser navigation for relative (same-origin) URLs that match one of your page routes. We sometimes need to tell Sapper that certain links need to be be handled by normal browser navigation.</p>\n<p>Adding a <code>rel=external</code> attribute to a link...</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">external</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&#x27;path&#x27;</span>&gt;</span>Path<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre></div><p>...will trigger a browser navigation when the link is clicked.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"sapper_noscroll\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#sapper_noscroll\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsapper:noscroll\n\t\t\t\t\t</h3><p>When navigating to internal links, Sapper will change the scroll position to 0,0 so that the user is at the very top left of the page. When a hash is defined, it will scroll to the element with a matching ID.</p>\n<p>In certain cases, you may wish to disable this behaviour. Adding a <code>sapper:noscroll</code> attribute to a link...</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&#x27;path&#x27;</span> <span class=\"hljs-attr\">sapper:noscroll</span>&gt;</span>Path<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre></div><p>...will prevent scrolling after the link is clicked.</p>\n","metadata":{"title":"Link options"},"subsections":[{"slug":"sapper_prefetch","title":"sapper:prefetch","level":3},{"slug":"rel_external","title":"rel=external","level":3},{"slug":"sapper_noscroll","title":"sapper:noscroll","level":3}],"slug":"Link_options","file":"08-link-options.md"},{"html":"<p>Up until now we&#39;ve been using <code>sapper dev</code> to build our application and run a development server. But when it comes to production, we want to create a self-contained optimized build.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"sapper_build\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#sapper_build\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsapper build\n\t\t\t\t\t</h3><p>This command packages up your application into the <code>__sapper__/build</code> directory. (You can change this to a custom directory, as well as controlling various other options — do <code>sapper build --help</code> for more information.)</p>\n<p>The output is a Node app that you can run from the project root:</p>\n<div class=''><pre class='language-bash'><code>node __sapper__/build</code></pre></div>\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Browser_support\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Browser_support\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tBrowser support\n\t\t\t\t\t</h3><p>Your site is built only for the latest versions of modern evergreen browsers by default. If you are using Rollup, you can use the <code>--legacy</code><sup>1</sup> flag to build a second bundle that can be used to support legacy browsers like Internet Explorer. Sapper will then serve up the correct bundle at runtime<sup>2</sup>.</p>\n<p>When using <code>--legacy</code>, Sapper will pass an environment variable <code>SAPPER_LEGACY_BUILD</code> to your Rollup config. Sapper will then build your client-side bundle twice: once with <code>SAPPER_LEGACY_BUILD</code> set to <code>true</code> and once with it set to <code>false</code>. <a href=\"https://github.com/sveltejs/sapper-template-rollup\" target=\"_blank\" rel=\"noopener noreferrer\">sapper-template-rollup</a> provides an example of utilizing this configuration.<sup>3</sup></p>\n<p>You may wish to add this flag to a script in your <code>package.json</code>:</p>\n<div class=''><pre class='language-javascript'><code>  <span class=\"hljs-string\">&quot;scripts&quot;</span>: {\n\t<span class=\"hljs-string\">&quot;build&quot;</span>: <span class=\"hljs-string\">&quot;sapper build --legacy&quot;</span>,\n  },</code></pre></div><ol>\n<li>This option is unrelated to Svelte&#39;s <code>legacy</code> option</li>\n<li>Browsers which do not support <code>async/await</code> syntax will be served the legacy bundle</li>\n<li>You will also need to polyfill APIs that are not present in older browsers.</li>\n</ol>\n","metadata":{"title":"Building"},"subsections":[{"slug":"sapper_build","title":"sapper build","level":3},{"slug":"Browser_support","title":"Browser support","level":3}],"slug":"Building","file":"09-building.md"},{"html":"<p>Many sites are effectively <em>static</em>, which is to say they don&#39;t actually need an Express server backing them. Instead, they can be hosted and served as static files, which allows them to be deployed to more hosting environments (such as <a href=\"https://www.netlify.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Netlify</a> or <a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub Pages</a>). Static sites are generally cheaper to operate and have better performance characteristics.</p>\n<p>Sapper allows you to <em>export</em> a static site with a single zero-config <code>sapper export</code> command. In fact, you&#39;re looking at an exported site right now!</p>\n<p>Static doesn&#39;t mean non-interactive — your Svelte components work exactly as they do normally, and you still get all the benefits of client-side routing and prefetching.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"sapper_export\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#sapper_export\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsapper export\n\t\t\t\t\t</h3><p>Inside your Sapper project, try this:</p>\n<div class=''><pre class='language-bash'><code><span class=\"hljs-comment\"># npx allows you to use locally-installed dependencies</span>\nnpx sapper <span class=\"hljs-built_in\">export</span></code></pre></div><p>This will create a <code>__sapper__/export</code> folder with a production-ready build of your site. You can launch it like so:</p>\n<div class=''><pre class='language-bash'><code>npx serve __sapper__/<span class=\"hljs-built_in\">export</span></code></pre></div><p>Navigate to <a href=\"http://localhost:5000\" target=\"_blank\" rel=\"noopener noreferrer\">localhost:5000</a> (or whatever port <code>serve</code> picked), and verify that your site works as expected.</p>\n<p>You can also add a script to your package.json...</p>\n<div class=''><pre class='language-javascript'><code>{\n\t<span class=\"hljs-string\">&quot;scripts&quot;</span>: {\n\t\t...\n\t\t<span class=\"hljs-string\">&quot;export&quot;</span>: <span class=\"hljs-string\">&quot;sapper export&quot;</span>\n\t}\n}</code></pre></div><p>...allowing you to <code>npm run export</code> your app.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"How_it_works\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#How_it_works\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tHow it works\n\t\t\t\t\t</h3><p>When you run <code>sapper export</code>, Sapper first builds a production version of your app, as though you had run <code>sapper build</code>, and copies the contents of your <code>static</code> folder to the destination. It then starts the server, and navigates to the root of your app. From there, it follows any <code>&lt;a&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;link&gt;</code> and <code>&lt;source&gt;</code> elements it finds pointing to local URLs, and captures any data served by the app.</p>\n<p>Because of this, any pages you want to be included in the exported site must either be reachable by <code>&lt;a&gt;</code> elements or added to the <code>--entry</code> option of the <code>sapper export</code> command.</p>\n<p>The <code>--entry</code> option expects a string of space-separated values. Examples:</p>\n<div class=''><pre class='language-bash'><code>sapper <span class=\"hljs-built_in\">export</span> --entry <span class=\"hljs-string\">&quot;some-page some-other-page&quot;</span></code></pre></div><p>Setting <code>--entry</code> overwrites any defaults. If you wish to add export entrypoints <em>in addition</em> to <code>/</code> then make sure to add <code>/</code> as well or <code>sapper export</code> will not visit the index route.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"When_not_to_export\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#When_not_to_export\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tWhen not to export\n\t\t\t\t\t</h3><p>The basic rule is this: for an app to be exportable, any two users hitting the same page of your app must get the same content from the server. In other words, any app that involves user sessions or authentication is <em>not</em> a candidate for <code>sapper export</code>.</p>\n<p>Note that you can still export apps with dynamic routes, like our <code>src/routes/blog/[slug].svelte</code> example from earlier. <code>sapper export</code> will intercept <code>fetch</code> requests made inside <code>preload</code>, so the data served from <code>src/routes/blog/[slug].json.js</code> will also be captured.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Route_conflicts\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Route_conflicts\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tRoute conflicts\n\t\t\t\t\t</h3><p>Because <code>sapper export</code> writes to the filesystem, it isn&#39;t possible to have two server routes that would cause a directory and a file to have the same name. For example, <code>src/routes/foo/index.js</code> and <code>src/routes/foo/bar.js</code> would try to create <code>export/foo</code> and <code>export/foo/bar</code>, which is impossible.</p>\n<p>The solution is to rename one of the routes to avoid conflict — for example, <code>src/routes/foo-bar.js</code>. (Note that you would also need to update any code that fetches data from <code>/foo/bar</code> to reference <code>/foo-bar</code> instead.)</p>\n<p>For <em>pages</em>, we skirt around this problem by writing <code>export/foo/index.html</code> instead of <code>export/foo</code>.</p>\n","metadata":{"title":"Exporting"},"subsections":[{"slug":"sapper_export","title":"sapper export","level":3},{"slug":"How_it_works","title":"How it works","level":3},{"slug":"When_not_to_export","title":"When not to export","level":3},{"slug":"Route_conflicts","title":"Route conflicts","level":3}],"slug":"Exporting","file":"10-exporting.md"},{"html":"<p>Sapper apps run anywhere that supports Node 10 or higher.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Deploying_from_sapper_build\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Deploying_from_sapper_build\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tDeploying from sapper build\n\t\t\t\t\t</h3><p>You will need the <code>__sapper__/build</code> and <code>static</code> directories as well as the production dependencies in <code>node_modules</code> to run the application. Node production dependencies can be generated with <code>npm ci --prod</code>, you can then start your app with:</p>\n<div class=''><pre class='language-bash'><code>node __sapper__/build</code></pre></div>\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Deploying_to_Vercel\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Deploying_to_Vercel\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tDeploying to Vercel\n\t\t\t\t\t</h3><p>We can use a third-party library like <a href=\"https://www.npmjs.com/package/vercel-sapper\" target=\"_blank\" rel=\"noopener noreferrer\">the <code>vercel-sapper</code> builder</a> to deploy our projects to <a href=\"https://vercel.com/home\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a> (<a href=\"https://vercel.com/blog/zeit-is-now-vercel\" target=\"_blank\" rel=\"noopener noreferrer\">formerly ZEIT Now</a>). See <a href=\"https://github.com/thgh/vercel-sapper#readme\" target=\"_blank\" rel=\"noopener noreferrer\">that project&#39;s readme</a> for more details regarding <a href=\"https://vercel.com/home\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a> deployments.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Deploying_service_workers\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Deploying_service_workers\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tDeploying service workers\n\t\t\t\t\t</h3><p>Sapper makes the Service Worker file (<code>service-worker.js</code>) unique by including a timestamp in the source code\n(calculated using <code>Date.now()</code>).</p>\n<p>In environments where the app is deployed to multiple servers (such as <a href=\"https://vercel.com/home\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a>), it is advisable to use a\nconsistent timestamp for all deployments. Otherwise, users may run into issues where the Service Worker\nupdates unexpectedly because the app hits server 1, then server 2, and they have slightly different timestamps.</p>\n<p>To override Sapper&#39;s timestamp, you can use an environment variable (e.g. <code>SAPPER_TIMESTAMP</code>) and then modify\nthe <code>service-worker.js</code>:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-keyword\">const</span> timestamp = process.env.SAPPER_TIMESTAMP; <span class=\"hljs-comment\">// instead of `import { timestamp }`</span>\n\n<span class=\"hljs-keyword\">const</span> ASSETS = <span class=\"hljs-string\">`cache<span class=\"hljs-subst\">${timestamp}</span>`</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n\t<span class=\"hljs-comment\">/* ... */</span>\n\t<span class=\"hljs-attr\">plugins</span>: [\n\t\t<span class=\"hljs-comment\">/* ... */</span>\n\t\treplace({\n\t\t\t<span class=\"hljs-comment\">/* ... */</span>\n\t\t\t<span class=\"hljs-string\">&#x27;process.env.SAPPER_TIMESTAMP&#x27;</span>: process.env.SAPPER_TIMESTAMP || <span class=\"hljs-built_in\">Date</span>.now()\n\t\t})\n\t]\n}</code></pre></div><p>Then you can set it using the environment variable, e.g.:</p>\n<div class=''><pre class='language-bash'><code>SAPPER_TIMESTAMP=$(date +%s%3N) npm run build</code></pre></div><p>When deploying to <a href=\"https://vercel.com/home\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a>, you can pass the environment variable into the Vercel CLI tool itself:</p>\n<div class=''><pre class='language-bash'><code>vercel -e SAPPER_TIMESTAMP=$(date +%s%3N)</code></pre></div>","metadata":{"title":"Deployment"},"subsections":[{"slug":"Deploying_from_sapper_build","title":"Deploying from sapper build","level":3},{"slug":"Deploying_to_Vercel","title":"Deploying to Vercel","level":3},{"slug":"Deploying_service_workers","title":"Deploying service workers","level":3}],"slug":"Deployment","file":"11-deploying.md"},{"html":"<p>By default, Sapper does not add security headers to your app, but you may add them yourself using middleware such as <a href=\"https://helmetjs.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Helmet</a>.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Content_Security_Policy_CSP\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Content_Security_Policy_CSP\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tContent Security Policy (CSP)\n\t\t\t\t\t</h3><p>Sapper generates inline <code>&lt;script&gt;</code>s and <code>&lt;style&gt;</code>s, which can fail to execute if <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\" target=\"_blank\" rel=\"noopener noreferrer\">Content Security Policy (CSP)</a> headers do not allow javascript or stylesheets sourced from inline resources.</p>\n<p>To work around this, Sapper can inject a <a href=\"https://www.troyhunt.com/locking-down-your-website-scripts-with-csp-hashes-nonces-and-report-uri/\" target=\"_blank\" rel=\"noopener noreferrer\">nonce</a> which can be configured with middleware to emit the proper CSP headers. The nonce will be applied to the inline <code>&lt;script&gt;</code>s and <code>&lt;style&gt;</code>s. Here is an example using <a href=\"https://expressjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Express</a> and <a href=\"https://helmetjs.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Helmet</a>:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-comment\">// server.js</span>\n<span class=\"hljs-keyword\">import</span> uuidv4 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;uuid/v4&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> helmet <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;helmet&#x27;</span>;\n\napp.use(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res, next</span>) =&gt;</span> {\n\tres.locals.nonce = uuidv4();\n\tnext();\n});\napp.use(helmet({\n\t<span class=\"hljs-attr\">contentSecurityPolicy</span>: {\n\t\t<span class=\"hljs-attr\">directives</span>: {\n\t\t\t<span class=\"hljs-attr\">scriptSrc</span>: [\n\t\t\t\t<span class=\"hljs-string\">&quot;&#x27;self&#x27;&quot;</span>,\n\t\t\t\t<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> <span class=\"hljs-string\">`&#x27;nonce-<span class=\"hljs-subst\">${res.locals.nonce}</span>&#x27;`</span>\n\t\t\t]\n\t\t}\n\t}\n}));\napp.use(sapper.middleware());</code></pre></div><p>Using <code>res.locals.nonce</code> in this way follows the convention set by\n<a href=\"https://helmetjs.github.io/docs/csp/#generating-nonces\" target=\"_blank\" rel=\"noopener noreferrer\">Helmet&#39;s CSP docs</a>.</p>\n<p>If a CSP nonce is set via <code>res.locals.nonce</code>, you can refer to that value via tag <code>%sapper.cspnonce%</code> in <code>src/template.html</code>. For instance:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">nonce</span>=<span class=\"hljs-string\">&quot;%sapper.cspnonce%&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;...&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div>","metadata":{"title":"Security"},"subsections":[{"slug":"Content_Security_Policy_CSP","title":"Content Security Policy (CSP)","level":3}],"slug":"Security","file":"12-security.md"},{"html":"<p>Ordinarily, the root of your Sapper app is served at <code>/</code>. But in some cases, your app may need to be served from a different base path — for example, if Sapper only controls part of your domain, or if you have multiple Sapper apps living side-by-side.</p>\n<p>This can be done like so:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-comment\">// app/server.js</span>\n\nexpress() <span class=\"hljs-comment\">// or Polka, or a similar framework</span>\n\t.use(\n\t\t<span class=\"hljs-string\">&#x27;/my-base-path&#x27;</span>, <span class=\"hljs-comment\">// &lt;!-- add this line</span>\n\t\tcompression({ <span class=\"hljs-attr\">threshold</span>: <span class=\"hljs-number\">0</span> }),\n\t\tserve(<span class=\"hljs-string\">&#x27;static&#x27;</span>),\n\t\tsapper.middleware()\n\t)\n\t.listen(process.env.PORT);</code></pre></div><p>Sapper will detect the base path and configure both the server-side and client-side routers accordingly.</p>\n<p>If you&#39;re <a href=\"docs#Exporting\" rel=\"noopener noreferrer\">exporting</a> your app, you will need to tell the exporter where to begin crawling:</p>\n<div class=''><pre class='language-bash'><code>sapper <span class=\"hljs-built_in\">export</span> --basepath my-base-path</code></pre></div>","metadata":{"title":"Base URLs"},"subsections":[],"slug":"Base_URLs","file":"13-base-urls.md"},{"html":"<p>Debugging your server code is particularly easy with <a href=\"https://github.com/GoogleChromeLabs/ndb\" target=\"_blank\" rel=\"noopener noreferrer\">ndb</a>. Install it globally...</p>\n<div class=''><pre class='language-bash'><code>npm install -g ndb</code></pre></div><p>...then run Sapper:</p>\n<div class=''><pre class='language-bash'><code>ndb npm run dev</code></pre></div><blockquote>\n<p>This assumes that <code>npm run dev</code> runs <code>sapper dev</code>. You can also run Sapper via <a href=\"https://blog.npmjs.org/post/162869356040/introducing-npx-an-npm-package-runner\" target=\"_blank\" rel=\"noopener noreferrer\">npx</a>, as in <code>ndb npx sapper dev</code>.</p>\n</blockquote>\n<p>Note that you may not see any terminal output for a few seconds while ndb starts up.</p>\n","metadata":{"title":"Debugging"},"subsections":[],"slug":"Debugging","file":"14-debugging.md"}]